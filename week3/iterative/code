goal_state = '123456780'

moves = {
    'U': -3,
    'D': 3,
    'L': -1,
    'R': 1
}

invalid_moves = {
    0: ['U', 'L'], 1: ['U'], 2: ['U', 'R'],
    3: ['L'],        5: ['R'],
    6: ['D', 'L'], 7: ['D'], 8: ['D', 'R']
}

def move_tile(state, direction):
    index = state.index('0')
    if direction in invalid_moves.get(index, []):
        return None
    new_index = index + moves[direction]
    if new_index < 0 or new_index >= 9:
        return None
    state_list = list(state)
    state_list[index], state_list[new_index] = state_list[new_index], state_list[index]
    return ''.join(state_list)

def dls(state, depth, path, visited):
    # Depth-limited DFS
    if state == goal_state:
        return path
    if depth == 0:
        return None

    visited.add(state)

    for direction in moves:
        new_state = move_tile(state, direction)
        if new_state and new_state not in visited:
            result = dls(new_state, depth - 1, path + [direction], visited)
            if result is not None:
                return result

    visited.remove(state)  # Backtrack
    return None

def iddfs(start_state, max_depth=50):
    for depth in range(max_depth + 1):
        visited = set()
        result = dls(start_state, depth, [], visited)
        if result is not None:
            return result
    return None

# Main
start = input("Enter start state (e.g., 724506831): ")

if len(start) == 9 and set(start) == set('012345678'):
    result = iddfs(start)
    if result is not None:
        print("Solution found using Iterative Deepening DFS!")
        print("Moves:", ' '.join(result))
        print("Number of moves:", len(result))
    else:
        print("No solution found within depth limit.")
else:
    print("Invalid input! Please enter a 9-digit string using digits 0-8 without repetition.")
print("Sarim Ali: 1BM23CS304")
